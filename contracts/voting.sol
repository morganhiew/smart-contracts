pragma solidity ^0.4.24;

contract voting{
    
    /*misc variables*/
    OaxMembership membershipLocation;
    uint proposalIdCount = 0;
    
    
    /*variables regarding the vote status of an individual voter*/
    //1. status of 'voted?' given voter address and given proposalId
    mapping (address => mapping (uint => bool)) Voted;
    //2. allow membership contract to check this attribute
    //as member that has a voted proposal in progress cannot transfer membership
    mapping (address => uint) CannotTransferUntil;
    
    /*variables regarding the proposal*/
    //1. status of the proposal
    enum status {open, denied, accepted}    
    //2. link an id to a unique proposal
    mapping (uint => Proposal) ProposalById;
    //3. things that each proposal contains
    struct Proposal {
        //this id duplicates the mapping
        uint proposalId;
        address proposer;
        bytes proposalContent;
        status proposalStatus;
        uint timeEnd;
        uint voteCount;
    }
    
    /*events*/
    event Propose (
        uint _id, address _proposer, bytes _content, uint _timeEnd
        );
    event Vote(
        uint _id, address _voter
        );
    event CloseProposal(
        uint _id, address _closer, status _status
        );
    
    /*function run at first setup*/
    //setup membership address for checking 
    constructor (address _membershipLocation) public {
	    membershipLocation = OaxMembership(_membershipLocation);
    }

    /*checkers for functions*/
    //check if is voting member
    modifier isVotingMember (address _memberAddress) {
        require (membershipLocation.isVotingMember(_memberAddress));
        _;
    }
    
    //check if is proposing member
    modifier isProposingMember (address _memberAddress) {
        require (membershipLocation.isMember(_memberAddress));
        _;
    }
    
    //maker sure voter has not voted
    modifier hasNotVoted (uint _proposalId, address _hasVotedAddress) {
        require (Voted[_hasVotedAddress][_proposalId] == false);
        _;
    }
    
    //make sure the following action must be done within the expiry period
    modifier proposalNotExpired (uint _expireProposalId) {
        require (now <= ProposalById[_expireProposalId].timeEnd);
        _;
    }
    
    /*functions*/
    
    /*
    main function 1: propose
    
    example input: content of proposal (i.e. 'hello world!')
    expected output: 
        a new proposal with the following properties
            proposalId: generated by smart contract, start from 0 to n
            proposer: the address which calls this propose function
            proposalContent: 68656c6c6f20776f726c6421 
                            (the HEX representation of hello world)
            proposalStatus: 0 (open)
            uint timeEnd: 3 days from this function call is being mined
            uint voteCount: 0
    restrictions: 
        content of proposal is not empty
        is prosing member
    */
    function propose (bytes _content) public isProposingMember(msg.sender) {
	    //require content not empty
        require (_content.length != 0);
        uint endTime = now + 3 days;
        //create a proposal with the following content
        ProposalById[proposalIdCount] = (Proposal
        (proposalIdCount, msg.sender, _content, 
        status.open, endTime, 0));

        emit Propose(proposalIdCount, msg.sender, _content, endTime);


        //increment id for next proposal to use
        proposalIdCount += 1;

    }
    
    /*
    main function 2: vote
    
    example input: id of proposal (i.e. 1)
    expected output: 
        vote count of proposal of id 1 increases by 1
        mark down the address which calls this function has already voted
        update the latest voting time of the voter
    
    restrictions: 
        address which calls this function is a voting member
        address which calls this function has not voted the same proposal before
        the proposal has not yet expired
    */    
    function vote (uint _voteProposalId) public 
    isVotingMember(msg.sender) 
    hasNotVoted(_voteProposalId,msg.sender)
    proposalNotExpired(_voteProposalId) {
        ProposalById[_voteProposalId].voteCount ++;
        //disallow the proposer to vote again
        Voted[msg.sender][_voteProposalId] = true;
        //update the voting time of this member
        CannotTransferUntil[msg.sender]= ProposalById[_voteProposalId].timeEnd;
        
        emit Vote(_voteProposalId, msg.sender);
    }

    /*
    main function 3: close proposal 
    
    example input: id of proposal (i.e. 1)
    expected output: 
        change the proposal status to accepted or denied according to:
            the vote count, which must exceed 1/2 of total no. of members
            the time, i.e. closes the proposal only after expiry period
    
    restrictions: 
        address which calls this function is a voting member
        address which calls this function has not voted the same proposal before
        the proposal has not yet expired
    */        
    function closeProposal (uint _closeProposalId) public {
        require (now > ProposalById[_closeProposalId].timeEnd 
        || ProposalById[_closeProposalId].voteCount > 1 
        /*voteCount > 1 is just a mock, 
        will be (membershipLocation.numberOfmember()+1)/2*/);
        
        /* TODO
        this function requires the membership contract to contain 
        numberOfmember (or similar) function
        this function calls the member no. counter in membership contract
        if (ProposalById[_closeProposalId].voteCount 
        > (membershipLocation.numberOfmember()+1)/2;
        */
        
        //the below is for demonstration and testing
        if (ProposalById[_closeProposalId].voteCount > 1){
            ProposalById[_closeProposalId].proposalStatus = status.accepted;
            emit CloseProposal(_closeProposalId, msg.sender, status.accepted);
        }
        else {
            ProposalById[_closeProposalId].proposalStatus = status.denied;
            emit CloseProposal(_closeProposalId, msg.sender, status.denied);
        }
        
        
    }
    
    
    /*view functions (not writing the smart contract)*/
    
    //retrieve info of proposal given id
    function getProposal (uint _getProposalId) public view returns(uint, address, bytes, status, uint, uint) {
        return (ProposalById[_getProposalId].proposalId, 
        ProposalById[_getProposalId].proposer, 
        ProposalById[_getProposalId].proposalContent,
        ProposalById[_getProposalId].proposalStatus,
        ProposalById[_getProposalId].timeEnd, 
        ProposalById[_getProposalId].voteCount);
        
    }
    
    //retrieve membership contract location which is setup initially
    function showMembership() public view returns(address) {
            return membershipLocation;
        }


}












contract OaxMembership {
    uint256 public constant MembershipStake = 10**18;
/*
    Token public memberToken;
    Token public gatewayToken;
    Token public votingToken;

    constructor(address _memberToken, address _gatewayToken, address _votingToken) public {
        memberToken = Token(_memberToken);
        gatewayToken = Token(_gatewayToken);
        votingToken = Token(_votingToken);
    }
*/
    function isMember(address _guy) public view returns(bool) {
       // return memberToken.balanceOf(_guy) >= MembershipStake;
       return true;
    }

    function isGatewayMember(address _guy) public view returns(bool) {
       // return gatewayToken.balanceOf(_guy) >= MembershipStake;
       return true;
    }

    function isVotingMember(address _guy) public view returns(bool) {
       // return votingToken.balanceOf(_guy) >= MembershipStake;
       return true;
    }
}
