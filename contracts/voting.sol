pragma solidity ^0.4.24;

contract voting{
    
    /*misc variables*/
    address membershipLocation;
    uint proposalIdCount = 0;
    
    
    /*variables regarding the vote status of an individual voter*/
    //1. status of 'voted?' given voter address and given proposalId
    mapping (address => mapping (uint => bool)) Voted;
    //2. allow membership contract to check this attribute
    //as member that has a voted proposal in progress cannot transfer membership
    mapping (address => uint) CannotTransferUntil;
    
    /*variables regarding the proposal*/
    //1. status of the proposal
    enum status {open, denied, accepted}    
    //2. link an id to a unique proposal
    mapping (uint => Proposal) ProposalById;
    //3. things that each proposal contains
    struct Proposal {
        //this id duplicates the mapping
        uint proposalId;
        address proposer;
        bytes proposalContent;
        status proposalStatus;
        uint timeEnd;
        uint voteCount;
    }
    
    /*function run at first setup*/
    //setup membership address for checking 
    //whether an address is a voting member etc. 
    constructor (address _membershipLocation) public {
	membershipLocation = _membershipLocation;
    }
    
    /*checkers for functions*/
    //check if is voting member
    modifier isVotingMember (address _memberAddress) {
        //TODO
        //needs the target membership contract to have 
        //an isMember (or similar )function
        //require (membershipLocation.isMember(_memberAddress));
        _;
    }
    
    //check if is proposing member
    modifier isProposingMember (address _memberAddress) {
        //TODO
        _;
    }
    
    //maker sure voter has not voted
    modifier hasNotVoted (uint _proposalId, address _hasVotedAddress) {
        require (Voted[_hasVotedAddress][_proposalId] == false);
        _;
    }
    
    //make sure the following action mustbe done within the expiry period
    modifier proposalNotExpired (uint _expireProposalId) {
        require (now <= ProposalById[_expireProposalId].timeEnd);
        _;
    }
    
    /*functions*/
    
    /*
    main function 1: propose
    
    example input: content of proposal (i.e. 'hello world!')
    expected output: 
        a new proposal with the following properties
            proposalId: generated by smart contract, start from 0 to n
            proposer: the address which calls this propose function
            proposalContent: 68656c6c6f20776f726c6421 
                            (the HEX representation of hello world)
            proposalStatus: 0 (open)
            uint timeEnd: 3 days from this function call is being mined
            uint voteCount: 0
    restrictions: 
        content of proposal is not empty
        is prosing member
    */
    function propose (bytes _content) public isProposingMember(msg.sender) {
	    //require content not empty
        require (_content.length != 0);
        //create a proposal with the following content
        ProposalById[proposalIdCount] = (Proposal
        (proposalIdCount, msg.sender, _content, 
        status.open, block.timestamp + 3 days, 0));
        //increment id for next proposal to use
        proposalIdCount += 1;
        
        //consider put the proposer's vote here too
        //concern is both voting and non-voting members can propose
        //which the increased complexity may lead to higher gas cost
        
    }
    
    /*
    main function 2: vote
    
    example input: id of proposal (i.e. 1)
    expected output: 
        vote count of proposal of id 1 increases by 1
        mark down the address which calls this function has already voted
        update the latest voting time of the voter
    
    restrictions: 
        address which calls this function is a voting member
        address which calls this function has not voted the same proposal before
        the proposal has not yet expired
    */    
    function vote (uint _voteProposalId) public 
    isVotingMember(msg.sender) 
    hasNotVoted(_voteProposalId,msg.sender)
    proposalNotExpired(_voteProposalId) {
        ProposalById[_voteProposalId].voteCount ++;
        //disallow the proposer to vote again
        Voted[msg.sender][_voteProposalId] = true;
        //update the voting time of this member
        CannotTransferUntil[msg.sender]= ProposalById[_voteProposalId].timeEnd;
        
    }

    /*
    main function 3: close proposal 
    
    example input: id of proposal (i.e. 1)
    expected output: 
        change the proposal status to accepted or denied according to:
            the vote count, which must exceed 1/2 of total no. of members
            the time, i.e. closes the proposal only after expiry period
    
    restrictions: 
        address which calls this function is a voting member
        address which calls this function has not voted the same proposal before
        the proposal has not yet expired
    */        
    function closeProposal (uint _closeProposalId) public {
        require (now > ProposalById[_closeProposalId].timeEnd 
        || ProposalById[_closeProposalId].voteCount > 1 
        /*voteCount > 1 is just a mock, 
        will be (membershipLocation.numberOfmember()+1)/2*/);
        
        /* TODO
        this function requires the membership contract to contain 
        numberOfmember (or similar) function
        this function calls the member no. counter in membership contract
        if (ProposalById[_closeProposalId].voteCount 
        > (membershipLocation.numberOfmember()+1)/2;
        */
        
        //the below is for demonstration and testing
        if (ProposalById[_closeProposalId].voteCount > 1){
            ProposalById[_closeProposalId].proposalStatus = status.accepted;
        }
        else {
        ProposalById[_closeProposalId].proposalStatus = status.denied;
        }
        
        
    }
    
    
    /*view functions (not writing the smart contract)*/
    
    //retrieve info of proposal given id
    function getProposal (uint _getProposalId) public view returns(uint, address, bytes, status, uint, uint) {
        return (ProposalById[_getProposalId].proposalId, 
        ProposalById[_getProposalId].proposer, 
        ProposalById[_getProposalId].proposalContent,
        ProposalById[_getProposalId].proposalStatus,
        ProposalById[_getProposalId].timeEnd, 
        ProposalById[_getProposalId].voteCount);
        
    }
    
    //retrieve membership contract location which is setup initially
    function showMembership() public view returns(address) {
            return membershipLocation;
        }


}


//questions1: success proposal means >50% of which date?